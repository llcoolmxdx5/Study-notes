# es6

## 严格模式

"use strict"

- 变量必须声明后再使用

- 函数的参数不能有同名属性，否则报错

- 不能使用with语句

- 不能对只读属性赋值，否则报错

- 不能使用前缀 0 表示八进制数，否则报错

- 不能删除不可删除的属性，否则报错

- 不能删除变量delete prop，会报错，只能删除属性delete global[prop]

- eval不会在它的外层作用域引入变量

- eval和arguments不能被重新赋值

- arguments不会自动反映函数参数的变化

- 不能使用arguments.callee

- 不能使用arguments.callee.caller

- 禁止this指向全局对象；顶层的this指向undefined，即不应该在顶层代码使用this。

- 不能使用fn.caller和fn.arguments获取函数调用的堆栈

- 增加了保留字（比如protected、static和interface）

## 变量声明

### 1.let

- let声明的变量不存在预解析

- let声明的变量不允许重复（在同一个作用域内）

- 不存在变量提升

- 块内部定义的变量，在外部是不可以访问的

- 在块级作用域内部，变量只能先声明再使用

### 2.const

- const用来声明常量

- const声明的常量不允许重新赋值

- const声明的常量必须初始化

- 注意声明对象时，只能保证对象指针地址不变，对象自身的改变不会因此影响

## Symbol类型

ES6 引入了一种新的原始数据类型Symbol，表示独一无二的值。它是 JavaScript 语言的第七种数据类型，前六种是：undefined、null、布尔值（Boolean）、字符串（String）、数值（Number）、对象（Object）

注意，Symbol函数的参数只是表示对当前 Symbol 值的描述，因此相同参数的Symbol函数的返回值是不相等的。

Symbol 值可以显式转为字符串，另外，Symbol 值也可以转为布尔值，但是不能转为数值

由于每一个 Symbol 值都是不相等的，这意味着 Symbol 值可以作为标识符，用于对象的属性名，就能保证不会出现同名的属性。这对于一个对象由多个模块构成的情况非常有用，能防止某一个键被不小心改写或覆盖。

```js
let mySymbol = Symbol();
// 第一种写法
let a = {};
a[mySymbol] = 'Hello!'
// 第二种写法
let a = {
  [mySymbol]: 'Hello!'
};
// 第三种写法
let a = {};
Object.defineProperty(a, mySymbol, { value: 'Hello!' });
// 以上写法都得到同样结果
a[mySymbol] // "Hello!"
```

Symbol 值作为对象属性名时，不能用点运算符 在对象的内部，使用 Symbol 值定义属性时，Symbol 值必须放在方括号之中。

Symbol 类型还可以用于定义一组常量，保证这组常量的值都是不相等的。

Symbol 作为属性名，该属性不会出现在for...in、for...of循环中，也不会被Object.keys()、Object.getOwnPropertyNames()、JSON.stringify()返回。但是，它也不是私有属性，有一个Object.getOwnPropertySymbols方法，可以获取指定对象的所有 Symbol 属性名。

Object.getOwnPropertySymbols方法返回一个数组，成员是当前对象的所有用作属性名的 Symbol 值。

## 解构赋值

### 1. 数组的解构赋值

```js
let [a,b,c] = [1,2,3];
[a, b] = [b, a] // 交换顺序
let [a, b=3] = 4 // 默认值
```

### 2. 对象的解构赋值

```js
let {foo,bar} = {foo : 'hello',bar : 'hi'};
//对象属性别名(如果有了别名，那么原来的名字就无效了)
// 对象的解构赋值的内部机制，是先找到同名属性，然后再赋给对应的变量。真正被赋值的是后者，而不是前者。
let {foo:abc,bar} = {bar : 'hi',foo : 'nihao'}; // abc:'nihao' foo未定义
//对象的解构赋值指定默认值  
let {foo:abc='hello',bar} = {bar : 'hi'};
```

### 3.字符串的解构赋值

```js
let [a,b,c,d,e,length] = "hello";
// a = "h"  length 未定义 "hello".length==5
let {length} = "hi";
//length==2
```

### 4. 参数解构赋值

```js
function foo({uname='lisi',age=13}={}){
    console.log(uname,age);
}
foo({uname:'zhangsan',age:15});
```

### 应用

1. 提取 JSON 数据

    ```js
    let jsonData = '{ "id": 42,"status": "OK","data": [867, 5309]}';
    let jsonObj = JSON.parse(jsonData)
    let { id, status, data: number } = jsonObj;
    console.log(id, status, number); // 42, "OK", [867, 5309]
    ```

2. 输入模块的指定方法

    ```js
    const { SourceMapConsumer, SourceNode } = require("source-map")
    ```

3. 从函数返回多个值

    ```js
    function example() {
        return [1, 2, 3];
    }
    let [a, b, c] = example();
    ```

4. 解构赋值仅适用于对象和类的静态方法和属性

## 字符串扩展

### 1.str.includes()

判断字符串中是否包含指定的字串（有的话返回true，否则返回false）
参数一：匹配的字串；参数二：从第几个开始匹配

### 2.str.startsWith()

判断字符串是否以特定的字串开始

### 3.str.endsWith()

判断字符串是否以特定的字串结束

### 4.str.repeat(n)

将字符串重复n次后返回

### 5.str.padStart()

"F".padStat(2,"0")
如果不够指定长度，在前面补足长度，例如这里F长度是1，需要补足2位，就在前面加了0

### 6.str.padEnd()

"F".padEnd(2,"0")

### 7.模板字符串

```js
let obj = {
username : 'lisi',
age : '12',
gender : 'male'
}
// 反引号表示模板，模板中的内容可以有格式，通过${}方式填充数据
let fn = function(info){
    return info;
}
let tpl = `
    <div>
        <span>${obj.username}</span>
        <span>${obj.age}</span>
        <span>${obj.gender}</span>
        <span>${1+1}</span>
        <span>${fn('nihao')}</span>
    </div>
`;
console.log(tpl);
```

### 8.标签模板

标签模板其实不是模板，而是函数调用的一种特殊形式。“标签”指的就是函数，紧跟在后面的模板字符串就是它的参数。

但是，如果模板字符里面有变量，就不是简单的调用了，而是会将模板字符串先处理成多个参数，再调用函数

```js
let a = 5;
let b = 10;
tag`Hello ${ a + b } world ${ a * b }`;
// 等同于
tag(['Hello ', ' world ', ''], 15, 50);
```

## 函数扩展

### 1. 参数默认值

```js
function foo(param = 'nihao'){
    console.log(param);
}
foo('hello kitty');
```

### 2. rest参数(剩余参数)

```js
function foo(a,b,...param){
    console.log(a);
    console.log(b);
    console.log(param);
}
foo(1,2,3,4,5);
```

### 3. 扩展运算符

```js
function foo(a,b,c,d,e,f,g){
    console.log(a + b + c + d + e + f + g);
}
let arr = [1,2,3,4,5,6,7];
foo(...arr); // 等效foo.apply(null,arr);
// 合并数组
let arr1 = [1,2,3];
let arr2 = [4,5,6];
let arr3 = [...arr1,...arr2];
console.log(arr3);
```

### 4. 箭头函数

```js
// 示例1
function foo(){
    console.log('hello');
}
foo();
let foo = () => console.log('hello');
foo();
// 示例2
function foo(v){
    return v;
}
let foo = v => v;
let ret = foo(111);
console.log(ret);
// 示例3
// 多个参数必须用小括号包住
let foo = (a,b) => {let c = 1; console.log(a + b + c);}
foo(1,2);
```

箭头函数的注意事项：

1. 箭头函数中this取决于函数的定义，而不是调用

    ```js
    function foo(){
        // 使用call调用foo时，这里的this其实就是call的第一个参数
        // console.log(this);
        setTimeout(()=>{
            console.log(this.num);
        },100);
    }
    foo.call({num:1});
    ```

2. 箭头函数不可以new

    ```js
    let foo = () => { this.num = 123;};
    new foo();
    ```

3. 箭头函数不可以使用arguments获取参数列表，可以使用rest参数代替

    ```js
    let foo = (a,b) => {
        // console.log(a,b);
        console.log(arguments);//这种方式获取不到实参列表
    }
    foo(123,456);
    let foo = (...param) => {
        console.log(param);
    }
    foo(123,456);
    ```

4. 对象下所有方法都是箭头函数时，所有方法的this会全部指向window

5. TODO

## 对象的扩展

## 类与继承

### 类

```js
class Animal{
    // 静态方法(静态方法只能通过类名调用，不可以使用实例对象调用)
    static showInfo(){
        console.log('hi');
    }
    // 构造函数 类似于Python __init__
    constructor(name){
        this.name = name;
    }
    showName(){
        console.log(this.name);
    }
}
let a = new Animal('spike');
a.showName();
// a.showInfo(); // 报错
Animal.showInfo();
```

### 继承

```js
class Dog extends Animal{
    constructor(name,color){
        super(name);//super用来调用父类
        this.color = color;
    }
    showColor(){
        console.log(this.color);
    }
}

let d = new Dog('doudou','yellow');
d.showName();
d.showColor();
// d.showInfo();
Dog.showInfo();
```

## Promise对象

```js
const promise = new Promise(function(resolve, reject){
  // 内容
});
promise
.then(result => {···})
.catch(error => {···})
.finally(() => {···}); //ES2018引入
```

resolve函数的作用是，将Promise对象的状态从“未完成”变为“成功”，在异步操作成功时调用，并将异步操作的结果，作为参数传递出去；

reject函数的作用是，将Promise对象的状态从“未完成”变为“失败”，在异步操作失败时调用，并将异步操作报出的错误，作为参数传递出去。

Promise实例生成以后，可以用then方法分别指定resolved状态和rejected状态的回调函数。
